
import React, { useState, useMemo } from 'react';
import { Transaction, TransactionType, Account, TransactionStatus, Contact, Category } from '../types';
import { ChevronLeft, ChevronRight, Plus } from 'lucide-react';
import TransactionModal from './TransactionModal';

interface CalendarViewProps {
  transactions: Transaction[];
  accounts: Account[];
  contacts: Contact[];
  categories: Category[];
  onAdd: (t: Omit<Transaction, 'id'>, newContact?: Contact, newCategory?: Category) => void;
  onEdit: (t: Transaction, newContact?: Contact, newCategory?: Category) => void;
}

interface CalendarItem {
  original: Transaction; // Reference to original data
  amount: number;
  type: TransactionType;
  description: string;
  isVirtual: boolean; // Generated by recurrence logic
  date: Date; // The specific date of this occurrence
}

interface CalendarEvent {
  dateStr: string; // YYYY-MM-DD
  items: CalendarItem[];
}

const CalendarView: React.FC<CalendarViewProps> = ({ transactions, accounts, contacts, categories, onAdd, onEdit }) => {
  const [currentDate, setCurrentDate] = useState(new Date());
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [selectedDateForNew, setSelectedDateForNew] = useState<string>('');
  const [editingTransaction, setEditingTransaction] = useState<Transaction | null>(null);

  const year = currentDate.getFullYear();
  const month = currentDate.getMonth();

  // --- Helpers ---
  const formatCurrency = (val: number) => 
    new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(val);

  const monthNames = [
    "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho",
    "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"
  ];

  const getDaysInMonth = (y: number, m: number) => new Date(y, m + 1, 0).getDate();
  const getFirstDayOfMonth = (y: number, m: number) => new Date(y, m, 1).getDay();

  // --- Data Generation (Similar to Reports but focused on current Month View) ---
  const calendarData = useMemo(() => {
    const events: Record<string, CalendarEvent['items']> = {};
    
    // Define range for the current view (with some buffer for recurrences)
    const startOfMonth = new Date(year, month, 1);
    const endOfMonth = new Date(year, month + 1, 0);

    transactions.forEach(t => {
      // 1. Non-Recurring
      if (!t.isRecurring) {
        const tDate = new Date(t.date);
        // Basic check: is it in this month?
        // Note: We use string comparison for the key to handle timezone offsets simply
        // Ideally we work with UTC, but local date string split is sufficient for this scope
        const dateKey = t.date; // YYYY-MM-DD
        
        // Only add if it belongs to the displayed month/year visually
        // (Actually, we might want to just dump everything into the map and let the grid render decide)
        // But for performance, let's filter lightly.
        if (tDate.getMonth() === month && tDate.getFullYear() === year) {
           if (!events[dateKey]) events[dateKey] = [];
           events[dateKey].push({
             original: t,
             amount: t.amount,
             type: t.type,
             description: t.description,
             isVirtual: false,
             date: tDate
           });
        }
        return;
      }

      // 2. Recurring Logic
      let iterDate = new Date(t.date);
      const recurrenceEnd = t.recurrenceEndDate ? new Date(t.recurrenceEndDate) : null;
      
      // We only care about occurrences inside the current month view
      // Optimization: jump closer to startOfMonth if possible, but simple iteration is fine for typical volumes
      const safetyLimit = new Date(year + 1, 0, 1); // Limit loop

      while (iterDate <= endOfMonth && iterDate <= safetyLimit) {
        if (recurrenceEnd && iterDate > recurrenceEnd) break;

        // Check if this occurrence falls within the current view month
        if (iterDate.getMonth() === month && iterDate.getFullYear() === year) {
            const dateKey = iterDate.toISOString().split('T')[0];
            if (!events[dateKey]) events[dateKey] = [];
            events[dateKey].push({
                original: t,
                amount: t.amount,
                type: t.type,
                description: t.description,
                isVirtual: true, // It's a projection
                date: new Date(iterDate)
            });
        }

        // Advance
        if (t.recurrenceFrequency === 'WEEKLY') {
            iterDate.setDate(iterDate.getDate() + 7);
        } else if (t.recurrenceFrequency === 'YEARLY') {
            iterDate.setFullYear(iterDate.getFullYear() + 1);
        } else {
            // MONTHLY
            iterDate.setMonth(iterDate.getMonth() + 1);
        }
      }
    });

    return events;
  }, [transactions, year, month]);

  // --- Handlers ---
  const handlePrevMonth = () => setCurrentDate(new Date(year, month - 1, 1));
  const handleNextMonth = () => setCurrentDate(new Date(year, month + 1, 1));

  const handleDayClick = (day: number) => {
    // Open modal to add transaction on this date
    const dateStr = new Date(year, month, day).toISOString().split('T')[0];
    setSelectedDateForNew(dateStr);
    setEditingTransaction(null);
    setIsModalOpen(true);
  };

  const handleEventClick = (e: React.MouseEvent, item: any) => {
    e.stopPropagation(); // Don't trigger day click
    // If virtual, we pass the original recurring transaction but maybe alert user they are editing the series
    // For MVP, we edit the "original" transaction record.
    setEditingTransaction(item.original);
    setIsModalOpen(true);
  };

  const handleSave = (t: Omit<Transaction, 'id'>, newContact?: Contact, newCategory?: Category) => {
    if (editingTransaction) {
        onEdit({ ...t, id: editingTransaction.id }, newContact, newCategory);
    } else {
        // Ensure date is respected if it came from the calendar click
        onAdd(t, newContact, newCategory);
    }
    setIsModalOpen(false);
    setEditingTransaction(null);
    setSelectedDateForNew('');
  };

  // --- Render Grid ---
  const daysInCurrentMonth = getDaysInMonth(year, month);
  const startDay = getFirstDayOfMonth(year, month); // 0 = Sunday
  
  const days = [];
  // Empty slots for start of month
  for (let i = 0; i < startDay; i++) {
    days.push(<div key={`empty-${i}`} className="bg-gray-50/30 border-r border-b border-gray-100 min-h-[100px]" />);
  }

  // Actual days
  for (let d = 1; d <= daysInCurrentMonth; d++) {
    const dateStr = new Date(year, month, d).toISOString().split('T')[0]; // Format matches map keys
    const dailyItems = calendarData[dateStr] || [];
    
    // Sort: Income first, then Expense
    dailyItems.sort((a, b) => (a.type === TransactionType.INCOME ? -1 : 1));

    const dayTotal = dailyItems.reduce((acc, i) => i.type === TransactionType.INCOME ? acc + i.amount : acc - i.amount, 0);
    const isToday = new Date().toDateString() === new Date(year, month, d).toDateString();

    days.push(
      <div 
        key={d} 
        onClick={() => handleDayClick(d)}
        className={`group relative min-h-[100px] border-r border-b border-gray-100 p-2 transition-colors hover:bg-indigo-50/30 cursor-pointer ${isToday ? 'bg-indigo-50/10' : 'bg-white'}`}
      >
        <div className="flex justify-between items-start mb-1">
            <span className={`text-sm font-medium w-7 h-7 flex items-center justify-center rounded-full ${isToday ? 'bg-indigo-600 text-white' : 'text-gray-700'}`}>
                {d}
            </span>
            {dailyItems.length > 0 && (
                <span className={`text-[10px] font-semibold ${dayTotal >= 0 ? 'text-emerald-600' : 'text-rose-600'}`}>
                    {dayTotal !== 0 && (dayTotal > 0 ? '+' : '') + Math.round(dayTotal)}
                </span>
            )}
        </div>
        
        <div className="space-y-1">
            {dailyItems.slice(0, 3).map((item, idx) => (
                <div 
                    key={idx}
                    onClick={(e) => handleEventClick(e, item)}
                    className={`text-[10px] px-1.5 py-0.5 rounded truncate flex items-center gap-1 border hover:opacity-80 transition-opacity
                        ${item.type === TransactionType.INCOME 
                            ? 'bg-emerald-50 text-emerald-700 border-emerald-100' 
                            : 'bg-rose-50 text-rose-700 border-rose-100'
                        }
                        ${item.original.status === TransactionStatus.PAID ? 'opacity-100' : 'opacity-70 border-dashed'}
                    `}
                    title={`${item.description} - ${formatCurrency(item.amount)} ${item.isVirtual ? '(Projeção)' : ''}`}
                >
                    <div className={`w-1.5 h-1.5 rounded-full ${item.type === TransactionType.INCOME ? 'bg-emerald-500' : 'bg-rose-500'}`} />
                    {item.description}
                </div>
            ))}
            {dailyItems.length > 3 && (
                <div className="text-[10px] text-gray-400 pl-1">
                    + {dailyItems.length - 3} mais
                </div>
            )}
        </div>

        {/* Hover Add Button */}
        <div className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity md:hidden lg:block">
            <Plus className="w-4 h-4 text-gray-300 hover:text-indigo-600" />
        </div>
      </div>
    );
  }

  // Totals for the Month Header
  const allItems = Object.values(calendarData).flat() as CalendarItem[];
  const totalIncome = allItems.filter(i => i.type === TransactionType.INCOME).reduce((acc, i) => acc + i.amount, 0);
  const totalExpense = allItems.filter(i => i.type === TransactionType.EXPENSE).reduce((acc, i) => acc + i.amount, 0);

  return (
    <div className="space-y-6 animate-fade-in">
        {/* Header */}
        <div className="flex flex-col md:flex-row items-center justify-between gap-4 bg-white p-4 rounded-2xl shadow-sm border border-gray-100">
            <div className="flex items-center gap-4">
                <div className="flex items-center bg-gray-50 rounded-xl p-1">
                    <button onClick={handlePrevMonth} className="p-2 hover:bg-white hover:shadow-sm rounded-lg text-gray-600 transition-all">
                        <ChevronLeft className="w-5 h-5" />
                    </button>
                    <span className="px-4 font-bold text-gray-800 min-w-[140px] text-center">
                        {monthNames[month]} {year}
                    </span>
                    <button onClick={handleNextMonth} className="p-2 hover:bg-white hover:shadow-sm rounded-lg text-gray-600 transition-all">
                        <ChevronRight className="w-5 h-5" />
                    </button>
                </div>
            </div>
            
            <div className="flex gap-6 text-sm">
                <div>
                    <span className="text-gray-500 block text-xs">Previsão Receitas</span>
                    <span className="font-bold text-emerald-600">{formatCurrency(totalIncome)}</span>
                </div>
                <div>
                    <span className="text-gray-500 block text-xs">Previsão Despesas</span>
                    <span className="font-bold text-rose-600">{formatCurrency(totalExpense)}</span>
                </div>
                <div>
                    <span className="text-gray-500 block text-xs">Saldo Previsto</span>
                    <span className={`font-bold ${totalIncome - totalExpense >= 0 ? 'text-indigo-600' : 'text-amber-600'}`}>
                        {formatCurrency(totalIncome - totalExpense)}
                    </span>
                </div>
            </div>
        </div>

        {/* Calendar Grid */}
        <div className="bg-white rounded-2xl shadow-sm border border-gray-200 overflow-hidden">
            {/* Days Header */}
            <div className="grid grid-cols-7 bg-gray-50 border-b border-gray-200">
                {['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb'].map(day => (
                    <div key={day} className="py-3 text-center text-xs font-semibold text-gray-500 uppercase tracking-wide">
                        {day}
                    </div>
                ))}
            </div>
            {/* Days Grid */}
            <div className="grid grid-cols-7 bg-gray-200 gap-px border-b border-gray-200">
                 {/* Gap-px creates borders between cells easily */}
                 {days}
            </div>
        </div>

        <TransactionModal 
            isOpen={isModalOpen}
            onClose={() => setIsModalOpen(false)}
            onSave={handleSave}
            accounts={accounts}
            contacts={contacts}
            categories={categories}
            initialData={editingTransaction ? editingTransaction : (selectedDateForNew ? { date: selectedDateForNew } as any : null)}
        />
    </div>
  );
};

export default CalendarView;
